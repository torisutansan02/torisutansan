---
title: 'Something'
date: 'June 21, 2024'
---

## Product of Array Except Self
In an integer array nums, return array answer such that answer[i] is equal to the product of all elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

Run an algorithm with O(n) time and without using division.

### Examples
- Input: nums = [1, 2, 3, 4].
- Output: [24, 12, 8, 6].

- Input: nums = [-1, 1, 0, -3, 3].
- Output: [0, 0, 9, 0, 0].

### Concept
Multiply the product of values before and after index.
- These two values multiply to get the value.
- 1, 2, 3, 4.
- Prefix: 1, 2, 6, 24.
- Postfix: 24, 24, 12, 4.
- Output: 24, 12, 8, 6.
- Time: O(n).
- Memory: O(n).
How to make this easier?
- 1, 2, 3, 4.
- Pre = 1, then 2, then 6.
- Output = 1, 1, 2, 6.
- Post = 1, then 4, then 12, then 24.
- Updated Output = 24, 12, 8, 6.

### Code
```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * (len(nums))

        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]

        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        
        return res
```

## Maximum Subarray
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

### Example
- Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4].
- Output: 6.
- Explanation: [4, -1, 2, 1] has the largest sum = 6.

### Concept
Start with the first index and find the sum for every proceeding index.

### Pseudocode
```
for (i = 0... n - 1)
    for (j = i... n - 1)
        for (k = i... j)

O(n^3).
```

### How to save time? (Pseudocode)
```
for (i = 0... n - 1)
    for (j = i... n - 1)
        currSum + num[j]

O(n^2).
```

### How to save even more time?
Who cares about negative numbers?
- Think of a sliding window.
- Increment right pointer.
- Shift left pointer if there is a negative prefix.
- Remove the negative prefixes!
- Time: O(n).

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        maxSub = nums[0]
        curSum = 0

        for n in nums:
            if curSum < 0:
                curSum = 0
            curSum += n
            maxSub = max(maxSub, curSum)
        return maxSub
```

## Maximum Product Subarray
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

### Example
- Input: [2, 3, -2, 4]
- Output: 6.
- Explanation: [2, 3] has the largest product 6.

### Brute Force
- [2, 3, -2, 4].
- 2 * 3 = 6.
- 2 * 3 * -2 = -12.
- 2 * 3 * -2 * 4 = -48.
- This is very slow.
- O(n^2).

### What about patterns?
- [1, 2, 3].
- 1 * 2 * 3 = 6.
- The product is always increasing.

### What about all negatives?
- [-1, -2, -3].
- -1 * -2 * -3 = -6.
- How can we find the real maximum product sub array?
- This is very confusing. Keep track of the minimum.
- We do this through subproblems.
- 2 * -3 = -6 (Min).
- -2 * -3 = 6 (Max).

### Edge Cases
- What if we had a 0 value?
- The 0 is going to kill us.
- 6 * 0 = 0.
- -6 * 0 = 0.
- x * 0 = 0.
- If we do get 0:
- Max = 1, Min = 1.

### Code
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = max(nums)
        curMin, curMax = 1, 1

        for n in nums:
            if n == 0:
                curMin, curMax = 1, 1
                continue
            tmp = curMax * n
            curMax = max(n * curMax, n * curMin, n)
            curMin = min(tmp, n * curMin, n)
            res = max(res, curMax)
        return res
```