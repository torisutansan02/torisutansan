{
  "id": "personal/20240621",
  "contentHtml": "<h2>Product of Array Except Self</h2>\n<p>In an integer array nums, return array answer such that answer[i] is equal to the product of all elements of nums except nums[i].</p>\n<p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p>\n<p>Run an algorithm with O(n) time and without using division.</p>\n<h3>Examples</h3>\n<ul>\n<li>\n<p>Input: nums = [1, 2, 3, 4].</p>\n</li>\n<li>\n<p>Output: [24, 12, 8, 6].</p>\n</li>\n<li>\n<p>Input: nums = [-1, 1, 0, -3, 3].</p>\n</li>\n<li>\n<p>Output: [0, 0, 9, 0, 0].</p>\n</li>\n</ul>\n<h3>Concept</h3>\n<p>Multiply the product of values before and after index.</p>\n<ul>\n<li>These two values multiply to get the value.</li>\n<li>1, 2, 3, 4.</li>\n<li>Prefix: 1, 2, 6, 24.</li>\n<li>Postfix: 24, 24, 12, 4.</li>\n<li>Output: 24, 12, 8, 6.</li>\n<li>Time: O(n).</li>\n<li>Memory: O(n).\nHow to make this easier?</li>\n<li>1, 2, 3, 4.</li>\n<li>Pre = 1, then 2, then 6.</li>\n<li>Output = 1, 1, 2, 6.</li>\n<li>Post = 1, then 4, then 12, then 24.</li>\n<li>Updated Output = 24, 12, 8, 6.</li>\n</ul>\n<h3>Code</h3>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">productExceptSelf</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -> <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]:\n        res = [<span class=\"hljs-number\">1</span>] * (<span class=\"hljs-built_in\">len</span>(nums))\n\n        prefix = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n\n        postfix = <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n            res[i] *= postfix\n            postfix *= nums[i]\n        \n        <span class=\"hljs-keyword\">return</span> res\n</code></pre>\n<h2>Maximum Subarray</h2>\n<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>\n<h3>Example</h3>\n<ul>\n<li>Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4].</li>\n<li>Output: 6.</li>\n<li>Explanation: [4, -1, 2, 1] has the largest sum = 6.</li>\n</ul>\n<h3>Concept</h3>\n<p>Start with the first index and find the sum for every proceeding index.</p>\n<h3>Pseudocode</h3>\n<pre><code>for (i = 0... n - 1)\n    for (j = i... n - 1)\n        for (k = i... j)\n\nO(n^3).\n</code></pre>\n<h3>How to save time? (Pseudocode)</h3>\n<pre><code>for (i = 0... n - 1)\n    for (j = i... n - 1)\n        currSum + num[j]\n\nO(n^2).\n</code></pre>\n<h3>How to save even more time?</h3>\n<p>Who cares about negative numbers?</p>\n<ul>\n<li>Think of a sliding window.</li>\n<li>Increment right pointer.</li>\n<li>Shift left pointer if there is a negative prefix.</li>\n<li>Remove the negative prefixes!</li>\n<li>Time: O(n).</li>\n</ul>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">maxSubArray</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -> <span class=\"hljs-built_in\">int</span>:\n        maxSub = nums[<span class=\"hljs-number\">0</span>]\n        curSum = <span class=\"hljs-number\">0</span>\n\n        <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> curSum &#x3C; <span class=\"hljs-number\">0</span>:\n                curSum = <span class=\"hljs-number\">0</span>\n            curSum += n\n            maxSub = <span class=\"hljs-built_in\">max</span>(maxSub, curSum)\n        <span class=\"hljs-keyword\">return</span> maxSub\n</code></pre>\n<h2>Maximum Product Subarray</h2>\n<p>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>\n<h3>Example</h3>\n<ul>\n<li>Input: [2, 3, -2, 4]</li>\n<li>Output: 6.</li>\n<li>Explanation: [2, 3] has the largest product 6.</li>\n</ul>\n<h3>Brute Force</h3>\n<ul>\n<li>[2, 3, -2, 4].</li>\n<li>2 * 3 = 6.</li>\n<li>2 * 3 * -2 = -12.</li>\n<li>2 * 3 * -2 * 4 = -48.</li>\n<li>This is very slow.</li>\n<li>O(n^2).</li>\n</ul>\n<h3>What about patterns?</h3>\n<ul>\n<li>[1, 2, 3].</li>\n<li>1 * 2 * 3 = 6.</li>\n<li>The product is always increasing.</li>\n</ul>\n<h3>What about all negatives?</h3>\n<ul>\n<li>[-1, -2, -3].</li>\n<li>-1 * -2 * -3 = -6.</li>\n<li>How can we find the real maximum product sub array?</li>\n<li>This is very confusing. Keep track of the minimum.</li>\n<li>We do this through subproblems.</li>\n<li>2 * -3 = -6 (Min).</li>\n<li>-2 * -3 = 6 (Max).</li>\n</ul>\n<h3>Edge Cases</h3>\n<ul>\n<li>What if we had a 0 value?</li>\n<li>The 0 is going to kill us.</li>\n<li>6 * 0 = 0.</li>\n<li>-6 * 0 = 0.</li>\n<li>x * 0 = 0.</li>\n<li>If we do get 0:</li>\n<li>Max = 1, Min = 1.</li>\n</ul>\n<h3>Code</h3>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">maxProduct</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -> <span class=\"hljs-built_in\">int</span>:\n        res = <span class=\"hljs-built_in\">max</span>(nums)\n        curMin, curMax = <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>\n\n        <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> nums:\n            <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">0</span>:\n                curMin, curMax = <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-keyword\">continue</span>\n            tmp = curMax * n\n            curMax = <span class=\"hljs-built_in\">max</span>(n * curMax, n * curMin, n)\n            curMin = <span class=\"hljs-built_in\">min</span>(tmp, n * curMin, n)\n            res = <span class=\"hljs-built_in\">max</span>(res, curMax)\n        <span class=\"hljs-keyword\">return</span> res\n</code></pre>\n<h2>あまり～ない</h2>\n<p>It means not very, not much ~.</p>\n<h3>How to use (使い方)</h3>\n<ul>\n<li>あまり　い-adjective + くない。</li>\n<li>あまり　な-adjective + じゃない。</li>\n<li>あまり　Verb (ない form).</li>\n<li>昨日の飲み会にはあまり人が来ませんでした。</li>\n<li>As for yesterday's drinking party, not many people came.</li>\n<li>冷たい飲み物があまり好きじゃありません。</li>\n<li>I don't like cold drinks much.</li>\n</ul>\n<h3>Examples</h3>\n<ul>\n<li>私はあまり運動しない。</li>\n<li>I don't exercise much.</li>\n<li>日本語があまりわからない。</li>\n<li>I don't understand Japanese much.</li>\n<li>ホラー映画はあまり見ない。</li>\n<li>I don't watch horror movies much.</li>\n<li>彼はあまり早く走ることができない。</li>\n<li>He is not able to run that fast.</li>\n<li>この文法があまりわかりません。教えて下さい。</li>\n<li>I cannot understand this grammar. Please teach me it.</li>\n<li>この食べ物はあまり美味しくなかった。</li>\n<li>This food was not that delicious.</li>\n<li>私はあまりテニスが上手ではない。</li>\n<li>I am not very good at tennis.</li>\n<li>冷たい飲み物があまり好きじゃありません。</li>\n<li>I do not like cold drinks much.</li>\n<li>最近は忙しくて、友だちとあまり遊んでいません。</li>\n<li>Recent times are busy and I cannot play with friends.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>Sometimes Japanese is hard to translate into English. I think the translations they give for JLPT practice is inadequate. As such, I am giving more straightforward translations.</p>\n<ul>\n<li>遊ぶ = To see a friend.</li>\n<li>However, the translation more properly means to \"play\" with a friend.</li>\n<li>I think the idea generally is to see or hang out with or enjoy the person's presence.</li>\n</ul>\n<h2>後で</h2>\n<p>It means after~; or later.</p>\n<h3>How to use (使い方)</h3>\n<ul>\n<li>Verb (た form)　後で</li>\n<li>Noun + の　あとで</li>\n<li>授業が終わった後で、部活に行く。</li>\n<li>After classes are finished, I will go to my club activities.</li>\n<li>宿題の後で、友達と遊びに行きます。</li>\n<li>After homework, I am going to play with friends.</li>\n</ul>\n<h3>Examples</h3>\n<ul>\n<li>図書館で宿田をした後で、帰ります。</li>\n<li>After I have finished homework at the library, I return.</li>\n<li>晩ご飯の後でアイスを食べた。</li>\n<li>After dinner, I ate ice cream.</li>\n<li>授業が終わったあとで、部活に行く。</li>\n<li>After classes have finished, I'm going to do club activities.</li>\n<li>お酒を飲んだ後で、運動してはダメですよ！</li>\n<li>After drinking, driving is no good.</li>\n<li>昼ご飯を食べた後で、３０分ほど昼寝をした。</li>\n<li>After eating lunch, I took about a 30 minute nap.</li>\n<li>大学を卒業した後で、本当の社会人になりました。</li>\n<li>After graduating college, I became a true member of society.</li>\n<li>宿題の後で、友達と遊びに行きます。</li>\n<li>After homework, I am going to play with friends.</li>\n<li>仕事の後で、飲み会があります。</li>\n<li>After work, there is a drinking party.</li>\n</ul>\n<h2>Find Minimum in Rotated Sorted Array</h2>\n<p>Suppose we have an array of length n sorted in ascending order that is rotated between 1 and n times. I.E., the array nums = [0, 1, 2, 4, 5, 6, 7] might become:</p>\n<ul>\n<li>[4, 5, 6, 7, 0, 1, 2] if it was rotated 4 times.</li>\n<li>[0, 1, 2, 3, 4, 5, 6, 7] if it was rotated 7 times.</li>\n</ul>\n<p>Note that rotating an array [a[0], a[1], a[2], ... a[n - 1]] 1 time results in the array [a[n - 1], a[0], a[1], a[2], ..., a[n - 2]].</p>\n<p>Given the sorted rotated array nums of unique elements, return the minimum element of this array.</p>\n<p>You must write an algorithm that runs in O(log(n)) runtime.</p>\n<h3>Example</h3>\n<ul>\n<li>Input: nums = [3, 4, 5, 1, 2].</li>\n<li>Output: 1.</li>\n<li>Explanation: The original array was [1, 2, 3, 4, 5] rotated 3 times.</li>\n</ul>\n<h3>Concept</h3>\n<p>Make the left pointer the first index and right pointer the last index.</p>\n<ul>\n<li>Find the pivot.</li>\n<li>This is where it's not in increasing order.</li>\n<li>Check if the middle pointer value is greater than or equal to the value at the left pointer.</li>\n</ul>\n<h3>Pseudocode</h3>\n<pre><code>nums[m] >= nums[L]\n    search Right\nelse\n    search Left\n</code></pre>\n<h3>Code</h3>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">findMin</span>(<span class=\"hljs-params\">self, nums: <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]</span>) -> <span class=\"hljs-built_in\">int</span>:\n        res = nums[<span class=\"hljs-number\">0</span>]\n\n        l, r = <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span>\n\n        <span class=\"hljs-keyword\">while</span> l &#x3C;= r:\n            <span class=\"hljs-keyword\">if</span> nums[l] &#x3C; nums[r]:\n                res = <span class=\"hljs-built_in\">min</span>(res, nums[l])\n                <span class=\"hljs-keyword\">break</span>\n            m = (l + r) // <span class=\"hljs-number\">2</span>\n            res = <span class=\"hljs-built_in\">min</span>(res, nums[m])\n            <span class=\"hljs-keyword\">if</span> nums[m] >= nums[l]:\n                l = m + <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">else</span>:\n                r = m - <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> res\n</code></pre>",
  "title": "Something",
  "date": "June 21, 2024",
  "category": "Personal",
  "categories": []
}